import { __decorate, __metadata } from "tslib";
import { Directive, Input } from '@angular/core';
import { ConfigurableNavigationMode } from '../navigation/configurable-navigation-mode';
import { WizardComponent } from '../components/wizard.component';
/**
 * The [[awNavigationMode]] directive can be used to customize wizard'd navigation mode.
 *
 * There are several usage options:
 *
 * ### Option 1. Customize the default navigation mode with [[navigateBackward]] and/or [[navigateForward]] inputs.
 *
 * ```html
 * <aw-wizard [awNavigationMode] navigateBackward="deny" navigateForward="allow">...</aw-wizard>
 * ```
 *
 * ### Option 2. Pass in a custom navigation mode
 *
 * ```typescript
 * import { BaseNavigationMode } from 'angular-archwizard'
 *
 * class CustomNavigationMode extends BaseNavigationMode {
 *
 *   // ...
 * }
 * ```
 *
 * ```typescript
 * @Component({
 *   // ...
 * })
 * class MyComponent {
 *
 *   navigationMode = new CustomNavigationMode();
 * }
 * ```
 *
 * ```html
 * <aw-wizard [awNavigationMode]="navigationMode">...</aw-wizard>
 * ```
 *
 * ### Additional Notes
 *
 * - Specifying a custom navigation mode takes priority over [[navigateBackward]] and [[navigateForward]] inputs
 *
 * - Omitting the [[awNavigationMode]] directive or, equally, specifying just [[awNavigationMode]] without
 *   any inputs or parameters causes the wizard to use the default "strict" navigation mode equivalent to
 *
 * ```html
 * <aw-wizard [awNavigationMode] navigateBackward="deny" navigateForward="allow">...</aw-wizard>
 * ````
 */
import * as ɵngcc0 from '@angular/core';
let NavigationModeDirective = class NavigationModeDirective {
    constructor(wizard) {
        this.wizard = wizard;
    }
    ngOnChanges(changes) {
        this.wizard.navigation = this.getNavigationMode();
    }
    getNavigationMode() {
        if (this.awNavigationMode) {
            return this.awNavigationMode;
        }
        return new ConfigurableNavigationMode(this.navigateBackward, this.navigateForward);
    }
};
NavigationModeDirective.ɵfac = function NavigationModeDirective_Factory(t) { return new (t || NavigationModeDirective)(ɵngcc0.ɵɵdirectiveInject(WizardComponent)); };
NavigationModeDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NavigationModeDirective, selectors: [["", "awNavigationMode", ""]], inputs: { awNavigationMode: "awNavigationMode", navigateBackward: "navigateBackward", navigateForward: "navigateForward" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
NavigationModeDirective.ctorParameters = () => [
    { type: WizardComponent }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], NavigationModeDirective.prototype, "awNavigationMode", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NavigationModeDirective.prototype, "navigateBackward", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NavigationModeDirective.prototype, "navigateForward", void 0);
NavigationModeDirective = __decorate([ __metadata("design:paramtypes", [WizardComponent])
], NavigationModeDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NavigationModeDirective, [{
        type: Directive,
        args: [{
                selector: '[awNavigationMode]'
            }]
    }], function () { return [{ type: WizardComponent }]; }, { awNavigationMode: [{
            type: Input
        }], navigateBackward: [{
            type: Input
        }], navigateForward: [{
            type: Input
        }] }); })();
export { NavigationModeDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdGlvbi1tb2RlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZXMiOlsibmc6L2FuZ3VsYXItYXJjaHdpemFyZC9saWIvZGlyZWN0aXZlcy9uYXZpZ2F0aW9uLW1vZGUuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFFLEtBQUssRUFBMkIsTUFBTSxlQUFlLENBQUM7QUFHekUsT0FBTyxFQUFDLDBCQUEwQixFQUFDLE1BQU0sNENBQTRDLENBQUM7QUFDdEYsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLGdDQUFnQyxDQUFDO0FBRy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFJSCxJQUFhLHVCQUF1QixHQUFwQyxNQUFhLHVCQUF1QjtBQUFHLElBMkJyQyxZQUFvQixNQUF1QjtBQUFJLFFBQTNCLFdBQU0sR0FBTixNQUFNLENBQWlCO0FBQUMsSUFBRyxDQUFDO0FBQ2xELElBQ1MsV0FBVyxDQUFDLE9BQXNCO0FBQUksUUFDM0MsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7QUFDdEQsSUFBRSxDQUFDO0FBQ0gsSUFDVSxpQkFBaUI7QUFBSyxRQUM1QixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtBQUMvQixZQUFNLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDO0FBQ25DLFNBQUs7QUFDTCxRQUFJLE9BQU8sSUFBSSwwQkFBMEIsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQ3ZGLElBQUUsQ0FBQztBQUNILENBQ0M7OzJTQUFBO0FBQ0Q7QUFBaUQsWUFkbkIsZUFBZTtBQUFHO0FBckI5QztBQUFhLElBRFosS0FBSyxFQUFFO0FBQ1Q7QUFBc0MsaUVBQVE7QUFTN0M7QUFBYSxJQURaLEtBQUssRUFBRTtBQUNUO0FBQXNDLGlFQUFRO0FBVTdDO0FBQWEsSUFEWixLQUFLLEVBQUU7QUFDVDtBQUFzQyxnRUFBaUI7QUF6QjNDLHVCQUF1QixvQkFIbkMsU0FBUyxDQUFDLFVBQ1QsUUFBUSxFQUFFLG5DQUVSLGtDQTJCMEIsZUFBZTtHQTdCYixPQUMvQixDQUFDLFhBNEI4QyxHQTNCbkMsdUJBQXVCLENBd0NuQzs7Ozs7Ozs7Ozs7O29CQUNEO0FBQUMsU0F6Q1ksdUJBQXVCO0FBQUkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0RpcmVjdGl2ZSwgSW5wdXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlc30gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7TmF2aWdhdGlvbk1vZGV9IGZyb20gJy4uL25hdmlnYXRpb24vbmF2aWdhdGlvbi1tb2RlLmludGVyZmFjZSc7XG5pbXBvcnQge0NvbmZpZ3VyYWJsZU5hdmlnYXRpb25Nb2RlfSBmcm9tICcuLi9uYXZpZ2F0aW9uL2NvbmZpZ3VyYWJsZS1uYXZpZ2F0aW9uLW1vZGUnO1xuaW1wb3J0IHtXaXphcmRDb21wb25lbnR9IGZyb20gJy4uL2NvbXBvbmVudHMvd2l6YXJkLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBUaGUgW1thd05hdmlnYXRpb25Nb2RlXV0gZGlyZWN0aXZlIGNhbiBiZSB1c2VkIHRvIGN1c3RvbWl6ZSB3aXphcmQnZCBuYXZpZ2F0aW9uIG1vZGUuXG4gKlxuICogVGhlcmUgYXJlIHNldmVyYWwgdXNhZ2Ugb3B0aW9uczpcbiAqXG4gKiAjIyMgT3B0aW9uIDEuIEN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBuYXZpZ2F0aW9uIG1vZGUgd2l0aCBbW25hdmlnYXRlQmFja3dhcmRdXSBhbmQvb3IgW1tuYXZpZ2F0ZUZvcndhcmRdXSBpbnB1dHMuXG4gKlxuICogYGBgaHRtbFxuICogPGF3LXdpemFyZCBbYXdOYXZpZ2F0aW9uTW9kZV0gbmF2aWdhdGVCYWNrd2FyZD1cImRlbnlcIiBuYXZpZ2F0ZUZvcndhcmQ9XCJhbGxvd1wiPi4uLjwvYXctd2l6YXJkPlxuICogYGBgXG4gKlxuICogIyMjIE9wdGlvbiAyLiBQYXNzIGluIGEgY3VzdG9tIG5hdmlnYXRpb24gbW9kZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IEJhc2VOYXZpZ2F0aW9uTW9kZSB9IGZyb20gJ2FuZ3VsYXItYXJjaHdpemFyZCdcbiAqXG4gKiBjbGFzcyBDdXN0b21OYXZpZ2F0aW9uTW9kZSBleHRlbmRzIEJhc2VOYXZpZ2F0aW9uTW9kZSB7XG4gKlxuICogICAvLyAuLi5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIEBDb21wb25lbnQoe1xuICogICAvLyAuLi5cbiAqIH0pXG4gKiBjbGFzcyBNeUNvbXBvbmVudCB7XG4gKlxuICogICBuYXZpZ2F0aW9uTW9kZSA9IG5ldyBDdXN0b21OYXZpZ2F0aW9uTW9kZSgpO1xuICogfVxuICogYGBgXG4gKlxuICogYGBgaHRtbFxuICogPGF3LXdpemFyZCBbYXdOYXZpZ2F0aW9uTW9kZV09XCJuYXZpZ2F0aW9uTW9kZVwiPi4uLjwvYXctd2l6YXJkPlxuICogYGBgXG4gKlxuICogIyMjIEFkZGl0aW9uYWwgTm90ZXNcbiAqXG4gKiAtIFNwZWNpZnlpbmcgYSBjdXN0b20gbmF2aWdhdGlvbiBtb2RlIHRha2VzIHByaW9yaXR5IG92ZXIgW1tuYXZpZ2F0ZUJhY2t3YXJkXV0gYW5kIFtbbmF2aWdhdGVGb3J3YXJkXV0gaW5wdXRzXG4gKlxuICogLSBPbWl0dGluZyB0aGUgW1thd05hdmlnYXRpb25Nb2RlXV0gZGlyZWN0aXZlIG9yLCBlcXVhbGx5LCBzcGVjaWZ5aW5nIGp1c3QgW1thd05hdmlnYXRpb25Nb2RlXV0gd2l0aG91dFxuICogICBhbnkgaW5wdXRzIG9yIHBhcmFtZXRlcnMgY2F1c2VzIHRoZSB3aXphcmQgdG8gdXNlIHRoZSBkZWZhdWx0IFwic3RyaWN0XCIgbmF2aWdhdGlvbiBtb2RlIGVxdWl2YWxlbnQgdG9cbiAqXG4gKiBgYGBodG1sXG4gKiA8YXctd2l6YXJkIFthd05hdmlnYXRpb25Nb2RlXSBuYXZpZ2F0ZUJhY2t3YXJkPVwiZGVueVwiIG5hdmlnYXRlRm9yd2FyZD1cImFsbG93XCI+Li4uPC9hdy13aXphcmQ+XG4gKiBgYGBgXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1thd05hdmlnYXRpb25Nb2RlXScsXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25Nb2RlRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcblxuICAvKipcbiAgICogQ3VzdG9tIG5hdmlnYXRpb24gbW9kZSBpbnN0YW5jZSAob3B0aW9uYWwpLlxuICAgKi9cbiAgQElucHV0KClcbiAgcHVibGljIGF3TmF2aWdhdGlvbk1vZGU6IE5hdmlnYXRpb25Nb2RlfG51bGw7XG5cbiAgLyoqXG4gICAqIEEgcGFyYW1ldGVyIGZvciB0aGUgZGVmYXVsdCBuYXZpZ2F0aW9uIG1vZGUuICBDb250cm9scyB3aGV0aGVyIHdpemFyZCBzdGVwcyBiZWZvcmUgdGhlIGN1cnJlbnQgc3RlcCBhcmUgbmF2aWdhYmxlOlxuICAgKlxuICAgKiAtIGBuYXZpZ2F0ZUJhY2t3YXJkPVwiZGVueVwiYCAtLSB0aGUgc3RlcHMgYXJlIG5vdCBuYXZpZ2FibGVcbiAgICogLSBgbmF2aWdhdGVCYWNrd2FyZD1cImFsbG93XCJgIC0tIHRoZSBzdGVwcyBhcmUgbmF2aWdhYmxlXG4gICAqL1xuICBASW5wdXQoKVxuICBwdWJsaWMgbmF2aWdhdGVCYWNrd2FyZDogJ2FsbG93J3wnZGVueSd8bnVsbDtcblxuICAvKipcbiAgICogQSBwYXJhbWV0ZXIgZm9yIHRoZSBkZWZhdWx0IG5hdmlnYXRpb24gbW9kZS4gIENvbnRyb2xzIHdoZXRoZXIgd2l6YXJkIHN0ZXBzIGFmdGVyIHRoZSBjdXJyZW50IHN0ZXAgYXJlIG5hdmlnYWJsZTpcbiAgICpcbiAgICogLSBgbmF2aWdhdGVGb3J3YXJkPVwiZGVueVwiYCAtLSB0aGUgc3RlcHMgYXJlIG5vdCBuYXZpZ2FibGVcbiAgICogLSBgbmF2aWdhdGVGb3J3YXJkPVwiYWxsb3dcImAgLS0gdGhlIHN0ZXBzIGFyZSBuYXZpZ2FibGVcbiAgICogLSBgbmF2aWdhdGVGb3J3YXJkPVwidmlzaXRlZFwiYCAtLSBhIHN0ZXAgaXMgbmF2aWdhYmxlIGlmZiBpdCB3YXMgYWxyZWFkeSB2aXNpdGVkIGJlZm9yZVxuICAgKi9cbiAgQElucHV0KClcbiAgcHVibGljIG5hdmlnYXRlRm9yd2FyZDogJ2FsbG93J3wnZGVueSd8J3Zpc2l0ZWQnfG51bGw7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB3aXphcmQ6IFdpemFyZENvbXBvbmVudCkgeyB9XG5cbiAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICB0aGlzLndpemFyZC5uYXZpZ2F0aW9uID0gdGhpcy5nZXROYXZpZ2F0aW9uTW9kZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXROYXZpZ2F0aW9uTW9kZSgpOiBOYXZpZ2F0aW9uTW9kZSB7XG4gICAgaWYgKHRoaXMuYXdOYXZpZ2F0aW9uTW9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXdOYXZpZ2F0aW9uTW9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb25maWd1cmFibGVOYXZpZ2F0aW9uTW9kZSh0aGlzLm5hdmlnYXRlQmFja3dhcmQsIHRoaXMubmF2aWdhdGVGb3J3YXJkKTtcbiAgfVxuXG59XG4iXX0=