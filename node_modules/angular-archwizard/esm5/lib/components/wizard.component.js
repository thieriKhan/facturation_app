import { __decorate, __metadata } from "tslib";
import { Component, ContentChildren, HostBinding, Input, QueryList, } from '@angular/core';
import { WizardStep } from '../util/wizard-step.interface';
import { MovingDirection } from '../util/moving-direction.enum';
import { ConfigurableNavigationMode } from '../navigation/configurable-navigation-mode';
/**
 * The `aw-wizard` component defines the root component of a wizard.
 * Through the setting of input parameters for the `aw-wizard` component it's possible to change the location and size
 * of its navigation bar.
 *
 * ### Syntax
 * ```html
 * <aw-wizard [navBarLocation]="location of navigation bar" [navBarLayout]="layout of navigation bar">
 *     ...
 * </aw-wizard>
 * ```
 *
 * ### Example
 *
 * Without completion step:
 *
 * ```html
 * <aw-wizard navBarLocation="top" navBarLayout="small">
 *     <aw-wizard-step>...</aw-wizard-step>
 *     <aw-wizard-step>...</aw-wizard-step>
 * </aw-wizard>
 * ```
 *
 * With completion step:
 *
 * ```html
 * <aw-wizard navBarLocation="top" navBarLayout="small">
 *     <aw-wizard-step>...</aw-wizard-step>
 *     <aw-wizard-step>...</aw-wizard-step>
 *     <aw-wizard-completion-step>...</aw-wizard-completion-step>
 * </aw-wizard>
 * ```
 *
 * @author Marc Arndt
 */
import * as ɵngcc0 from '@angular/core';

var _c0 = function (a0, a1, a2, a3, a4, a5, a6) { return { "vertical": a0, "horizontal": a1, "small": a2, "large-filled": a3, "large-filled-symbols": a4, "large-empty": a5, "large-empty-symbols": a6 }; };
function WizardComponent_aw_wizard_navigation_bar_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "aw-wizard-navigation-bar", 2);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("direction", ctx_r0.navBarDirection)("ngClass", ɵngcc0.ɵɵpureFunction7(2, _c0, ctx_r0.navBarLocation == "left", ctx_r0.navBarLocation == "top", ctx_r0.navBarLayout == "small", ctx_r0.navBarLayout == "large-filled", ctx_r0.navBarLayout == "large-filled-symbols", ctx_r0.navBarLayout == "large-empty", ctx_r0.navBarLayout == "large-empty-symbols"));
} }
function WizardComponent_aw_wizard_navigation_bar_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "aw-wizard-navigation-bar", 2);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("direction", ctx_r1.navBarDirection)("ngClass", ɵngcc0.ɵɵpureFunction7(2, _c0, ctx_r1.navBarLocation == "right", ctx_r1.navBarLocation == "bottom", ctx_r1.navBarLayout == "small", ctx_r1.navBarLayout == "large-filled", ctx_r1.navBarLayout == "large-filled-symbols", ctx_r1.navBarLayout == "large-empty", ctx_r1.navBarLayout == "large-empty-symbols"));
} }
var _c1 = function (a1, a2) { return { "wizard-steps": true, "vertical": a1, "horizontal": a2 }; };
var _c2 = ["*"];
var WizardComponent = /** @class */ (function () {
    /**
     * Constructor
     */
    function WizardComponent() {
        /**
         * The location of the navigation bar inside the wizard.
         * This location can be either top, bottom, left or right
         */
        this.navBarLocation = 'top';
        /**
         * The layout of the navigation bar inside the wizard.
         * The layout can be either small, large-filled, large-empty or large-symbols
         */
        this.navBarLayout = 'small';
        /**
         * The direction in which the steps inside the navigation bar should be shown.
         * The direction can be either `left-to-right` or `right-to-left`
         */
        this.navBarDirection = 'left-to-right';
        this._defaultStepIndex = 0;
        /**
         * True, if the navigation bar shouldn't be used for navigating
         */
        this.disableNavigationBar = false;
        /**
         * The navigation mode used to navigate inside the wizard
         *
         * For outside access, use the [[navigation]] getter.
         */
        this._navigation = new ConfigurableNavigationMode();
        /**
         * An array representation of all wizard steps belonging to this model
         *
         * For outside access, use the [[wizardSteps]] getter.
         */
        this._wizardSteps = [];
        /**
         * The index of the currently visible and selected step inside the wizardSteps QueryList.
         * If this wizard contains no steps, currentStepIndex is -1
         *
         * Note: Do not modify this field directly.  Instead, use navigation methods:
         * [[goToStep]], [[goToPreviousStep]], [[goToNextStep]].
         */
        this.currentStepIndex = -1;
    }
    Object.defineProperty(WizardComponent.prototype, "defaultStepIndex", {
        /**
         * The initially selected step, represented by its index
         * Beware: This initial default is only used if no wizard step has been enhanced with the `selected` directive
         */
        get: function () {
            // This value can be either:
            // - the index of a wizard step with a `selected` directive, or
            // - the default step index, set in the [[WizardComponent]]
            var foundDefaultStep = this.wizardSteps.find(function (step) { return step.defaultSelected; });
            if (foundDefaultStep) {
                return this.getIndexOfStep(foundDefaultStep);
            }
            else {
                return this._defaultStepIndex;
            }
        },
        set: function (defaultStepIndex) {
            this._defaultStepIndex = defaultStepIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardComponent.prototype, "horizontalOrientation", {
        /**
         * Returns true if this wizard uses a horizontal orientation.
         * The wizard uses a horizontal orientation, iff the navigation bar is shown at the top or bottom of this wizard
         *
         * @returns True if this wizard uses a horizontal orientation
         */
        get: function () {
            return this.navBarLocation === 'top' || this.navBarLocation === 'bottom';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardComponent.prototype, "verticalOrientation", {
        /**
         * Returns true if this wizard uses a vertical orientation.
         * The wizard uses a vertical orientation, iff the navigation bar is shown at the left or right of this wizard
         *
         * @returns True if this wizard uses a vertical orientation
         */
        get: function () {
            return this.navBarLocation === 'left' || this.navBarLocation === 'right';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initialization work
     */
    WizardComponent.prototype.ngAfterContentInit = function () {
        var _this = this;
        // add a subscriber to the wizard steps QueryList to listen to changes in the DOM
        this.wizardStepsQueryList.changes.subscribe(function (changedWizardSteps) {
            _this.updateWizardSteps(changedWizardSteps.toArray());
        });
        // initialize the model
        this.updateWizardSteps(this.wizardStepsQueryList.toArray());
        // finally reset the whole wizard component
        setTimeout(function () { return _this.reset(); });
    };
    Object.defineProperty(WizardComponent.prototype, "currentStep", {
        /**
         * The WizardStep object belonging to the currently visible and selected step.
         * The currentStep is always the currently selected wizard step.
         * The currentStep can be either completed, if it was visited earlier,
         * or not completed, if it is visited for the first time or its state is currently out of date.
         *
         * If this wizard contains no steps, currentStep is null
         */
        get: function () {
            if (this.hasStep(this.currentStepIndex)) {
                return this.wizardSteps[this.currentStepIndex];
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardComponent.prototype, "completed", {
        /**
         * The completeness of the wizard.
         * If the wizard has been completed, i.e. all steps are either completed or optional, this value is true, otherwise it is false
         */
        get: function () {
            return this.wizardSteps.every(function (step) { return step.completed || step.optional; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardComponent.prototype, "wizardSteps", {
        /**
         * An array representation of all wizard steps belonging to this model
         */
        get: function () {
            return this._wizardSteps;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates the wizard steps to the new array
     *
     * @param wizardSteps The updated wizard steps
     */
    WizardComponent.prototype.updateWizardSteps = function (wizardSteps) {
        // the wizard is currently not in the initialization phase
        if (this.wizardSteps.length > 0 && this.currentStepIndex > -1) {
            this.currentStepIndex = wizardSteps.indexOf(this.wizardSteps[this.currentStepIndex]);
        }
        this._wizardSteps = wizardSteps;
    };
    Object.defineProperty(WizardComponent.prototype, "navigation", {
        /**
         * The navigation mode used to navigate inside the wizard
         */
        get: function () {
            return this._navigation;
        },
        /**
         * Updates the navigation mode for this wizard component
         *
         * @param navigation The updated navigation mode
         */
        set: function (navigation) {
            this._navigation = navigation;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks if a given index `stepIndex` is inside the range of possible wizard steps inside this wizard
     *
     * @param stepIndex The to be checked index of a step inside this wizard
     * @returns True if the given `stepIndex` is contained inside this wizard, false otherwise
     */
    WizardComponent.prototype.hasStep = function (stepIndex) {
        return this.wizardSteps.length > 0 && 0 <= stepIndex && stepIndex < this.wizardSteps.length;
    };
    /**
     * Checks if this wizard has a previous step, compared to the current step
     *
     * @returns True if this wizard has a previous step before the current step
     */
    WizardComponent.prototype.hasPreviousStep = function () {
        return this.hasStep(this.currentStepIndex - 1);
    };
    /**
     * Checks if this wizard has a next step, compared to the current step
     *
     * @returns True if this wizard has a next step after the current step
     */
    WizardComponent.prototype.hasNextStep = function () {
        return this.hasStep(this.currentStepIndex + 1);
    };
    /**
     * Checks if this wizard is currently inside its last step
     *
     * @returns True if the wizard is currently inside its last step
     */
    WizardComponent.prototype.isLastStep = function () {
        return this.wizardSteps.length > 0 && this.currentStepIndex === this.wizardSteps.length - 1;
    };
    /**
     * Finds the [[WizardStep]] at the given index `stepIndex`.
     * If no [[WizardStep]] exists at the given index an Error is thrown
     *
     * @param stepIndex The given index
     * @returns The found [[WizardStep]] at the given index `stepIndex`
     * @throws An `Error` is thrown, if the given index `stepIndex` doesn't exist
     */
    WizardComponent.prototype.getStepAtIndex = function (stepIndex) {
        if (!this.hasStep(stepIndex)) {
            throw new Error("Expected a known step, but got stepIndex: " + stepIndex + ".");
        }
        return this.wizardSteps[stepIndex];
    };
    /**
     * Finds the index of the step with the given `stepId`.
     * If no step with the given `stepId` exists, `-1` is returned
     *
     * @param stepId The given step id
     * @returns The found index of a step with the given step id, or `-1` if no step with the given id is included in the wizard
     */
    WizardComponent.prototype.getIndexOfStepWithId = function (stepId) {
        return this.wizardSteps.findIndex(function (step) { return step.stepId === stepId; });
    };
    /**
     * Finds the index of the given [[WizardStep]] `step`.
     * If the given [[WizardStep]] is not contained inside this wizard, `-1` is returned
     *
     * @param step The given [[WizardStep]]
     * @returns The found index of `step` or `-1` if the step is not included in the wizard
     */
    WizardComponent.prototype.getIndexOfStep = function (step) {
        return this.wizardSteps.indexOf(step);
    };
    /**
     * Calculates the correct [[MovingDirection]] value for a given `destinationStep` compared to the `currentStepIndex`.
     *
     * @param destinationStep The given destination step
     * @returns The calculated [[MovingDirection]]
     */
    WizardComponent.prototype.getMovingDirection = function (destinationStep) {
        var movingDirection;
        if (destinationStep > this.currentStepIndex) {
            movingDirection = MovingDirection.Forwards;
        }
        else if (destinationStep < this.currentStepIndex) {
            movingDirection = MovingDirection.Backwards;
        }
        else {
            movingDirection = MovingDirection.Stay;
        }
        return movingDirection;
    };
    /**
     * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.
     *
     * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.
     * Navigation by navigation bar is governed by [[isNavigable]].
     *
     * @param destinationIndex The index of the destination step
     * @returns A [[Promise]] containing `true`, if the destination step can be transitioned to and false otherwise
     */
    WizardComponent.prototype.canGoToStep = function (destinationIndex) {
        return this.navigation.canGoToStep(this, destinationIndex);
    };
    /**
     * Tries to transition to the wizard step, as denoted by the given destination index.
     *
     * Note: You do not have to call [[canGoToStep]] before calling [[goToStep]].
     * The [[canGoToStep]] method will be called automatically.
     *
     * @param destinationIndex The index of the destination wizard step, which should be entered
     * @param preFinalize An event emitter, to be called before the step has been transitioned
     * @param postFinalize An event emitter, to be called after the step has been transitioned
     */
    WizardComponent.prototype.goToStep = function (destinationIndex, preFinalize, postFinalize) {
        return this.navigation.goToStep(this, destinationIndex, preFinalize, postFinalize);
    };
    /**
     * Tries to transition the wizard to the previous step
     *
     * @param preFinalize An event emitter, to be called before the step has been transitioned
     * @param postFinalize An event emitter, to be called after the step has been transitioned
     */
    WizardComponent.prototype.goToPreviousStep = function (preFinalize, postFinalize) {
        return this.navigation.goToStep(this, this.currentStepIndex - 1, preFinalize, postFinalize);
    };
    /**
     * Tries to transition the wizard to the next step
     *
     * @param preFinalize An event emitter, to be called before the step has been transitioned
     * @param postFinalize An event emitter, to be called after the step has been transitioned
     */
    WizardComponent.prototype.goToNextStep = function (preFinalize, postFinalize) {
        return this.navigation.goToStep(this, this.currentStepIndex + 1, preFinalize, postFinalize);
    };
    /**
     * Checks, whether the wizard step, located at the given index, can be navigated to using the navigation bar.
     *
     * @param destinationIndex The index of the destination step
     * @returns True if the step can be navigated to, false otherwise
     */
    WizardComponent.prototype.isNavigable = function (destinationIndex) {
        return this.navigation.isNavigable(this, destinationIndex);
    };
    /**
     * Resets the state of this wizard.
     */
    WizardComponent.prototype.reset = function () {
        this.navigation.reset(this);
    };
    __decorate([
        ContentChildren(WizardStep, { descendants: true }),
        __metadata("design:type", QueryList)
    ], WizardComponent.prototype, "wizardStepsQueryList", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], WizardComponent.prototype, "navBarLocation", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], WizardComponent.prototype, "navBarLayout", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], WizardComponent.prototype, "navBarDirection", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], WizardComponent.prototype, "defaultStepIndex", null);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], WizardComponent.prototype, "disableNavigationBar", void 0);
    __decorate([
        HostBinding('class.horizontal'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], WizardComponent.prototype, "horizontalOrientation", null);
    __decorate([
        HostBinding('class.vertical'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], WizardComponent.prototype, "verticalOrientation", null);
    WizardComponent = __decorate([ __metadata("design:paramtypes", [])
    ], WizardComponent);
WizardComponent.ɵfac = function WizardComponent_Factory(t) { return new (t || WizardComponent)(); };
WizardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: WizardComponent, selectors: [["aw-wizard"]], contentQueries: function WizardComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, WizardStep, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.wizardStepsQueryList = _t);
    } }, hostVars: 4, hostBindings: function WizardComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("horizontal", ctx.horizontalOrientation)("vertical", ctx.verticalOrientation);
    } }, inputs: { navBarLocation: "navBarLocation", navBarLayout: "navBarLayout", navBarDirection: "navBarDirection", disableNavigationBar: "disableNavigationBar", defaultStepIndex: "defaultStepIndex" }, ngContentSelectors: _c2, decls: 4, vars: 6, consts: [[3, "direction", "ngClass", 4, "ngIf"], [3, "ngClass"], [3, "direction", "ngClass"]], template: function WizardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, WizardComponent_aw_wizard_navigation_bar_0_Template, 1, 10, "aw-wizard-navigation-bar", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, WizardComponent_aw_wizard_navigation_bar_3_Template, 1, 10, "aw-wizard-navigation-bar", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.navBarLocation == "top" || ctx.navBarLocation == "left");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(3, _c1, ctx.navBarLocation == "left" || ctx.navBarLocation == "right", ctx.navBarLocation == "top" || ctx.navBarLocation == "bottom"));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.navBarLocation == "bottom" || ctx.navBarLocation == "right");
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(WizardComponent, [{
        type: Component,
        args: [{
                selector: 'aw-wizard',
                template: "<aw-wizard-navigation-bar\n  [direction]=\"navBarDirection\"\n  *ngIf=\"navBarLocation == 'top' || navBarLocation == 'left'\"\n  [ngClass]=\"{\n    'vertical': navBarLocation == 'left',\n    'horizontal': navBarLocation == 'top',\n    'small': navBarLayout == 'small',\n    'large-filled': navBarLayout == 'large-filled',\n    'large-filled-symbols': navBarLayout == 'large-filled-symbols',\n    'large-empty': navBarLayout == 'large-empty',\n    'large-empty-symbols': navBarLayout == 'large-empty-symbols'\n  }\">\n</aw-wizard-navigation-bar>\n\n<div [ngClass]=\"{\n  'wizard-steps': true,\n  'vertical': navBarLocation == 'left' || navBarLocation == 'right',\n  'horizontal': navBarLocation == 'top' || navBarLocation == 'bottom'\n}\">\n  <ng-content></ng-content>\n</div>\n\n<aw-wizard-navigation-bar\n  [direction]=\"navBarDirection\"\n  *ngIf=\"navBarLocation == 'bottom' || navBarLocation == 'right'\"\n  [ngClass]=\"{\n    'vertical': navBarLocation == 'right',\n    'horizontal': navBarLocation == 'bottom',\n    'small': navBarLayout == 'small',\n    'large-filled': navBarLayout == 'large-filled',\n    'large-filled-symbols': navBarLayout == 'large-filled-symbols',\n    'large-empty': navBarLayout == 'large-empty',\n    'large-empty-symbols': navBarLayout == 'large-empty-symbols'\n  }\">\n</aw-wizard-navigation-bar>\n"
            }]
    }], function () { return []; }, { navBarLocation: [{
            type: Input
        }], navBarLayout: [{
            type: Input
        }], navBarDirection: [{
            type: Input
        }], disableNavigationBar: [{
            type: Input
        }], defaultStepIndex: [{
            type: Input
        }], horizontalOrientation: [{
            type: HostBinding,
            args: ['class.horizontal']
        }], verticalOrientation: [{
            type: HostBinding,
            args: ['class.vertical']
        }], wizardStepsQueryList: [{
            type: ContentChildren,
            args: [WizardStep, { descendants: true }]
        }] }); })();
    return WizardComponent;
}());
export { WizardComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2l6YXJkLmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsibmc6L2FuZ3VsYXItYXJjaHdpemFyZC9saWIvY29tcG9uZW50cy93aXphcmQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBRUwsU0FBUyxFQUNULGVBQWUsRUFDZixXQUFXLEVBQ1gsS0FBSyxFQUNMLFNBQVMsR0FFVixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sK0JBQStCLENBQUM7QUFDekQsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLCtCQUErQixDQUFDO0FBQzlELE9BQU8sRUFBQywwQkFBMEIsRUFBQyxNQUFNLDRDQUE0QyxDQUFDO0FBRXRGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0g7QUFBbUQsSUFnRmpEO0FBQ0Y7QUFDRSxPQUFHO0FBQ0wsSUFBRTtBQUlBLFFBaEZBO0FBQ0Y7QUFDTTtBQUVBLFdBREQ7QUFDTCxRQUNTLG1CQUFjLEdBQUcsS0FBSyxDQUFDO0FBQ2hDLFFBQ0U7QUFDRjtBQUNNO0FBRUEsV0FERDtBQUNMLFFBQ1MsaUJBQVksR0FBRyxPQUFPLENBQUM7QUFDaEMsUUFDRTtBQUNGO0FBQ007QUFFQSxXQUREO0FBQ0wsUUFDUyxvQkFBZSxHQUFHLGVBQWUsQ0FBQztBQUMzQyxRQXNCVSxzQkFBaUIsR0FBRyxDQUFDLENBQUM7QUFDaEMsUUFDRTtBQUNGO0FBRUEsV0FESztBQUNMLFFBQ1MseUJBQW9CLEdBQUcsS0FBSyxDQUFDO0FBQ3RDLFFBQ0U7QUFDRjtBQUVDO0FBQVc7QUFFQSxX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SUF1VkM7QUFDRCxTQXhWYSxlQUFlO0FBQUkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgSG9zdEJpbmRpbmcsXG4gIElucHV0LFxuICBRdWVyeUxpc3QsXG4gIEV2ZW50RW1pdHRlcixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge05hdmlnYXRpb25Nb2RlfSBmcm9tICcuLi9uYXZpZ2F0aW9uL25hdmlnYXRpb24tbW9kZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHtXaXphcmRTdGVwfSBmcm9tICcuLi91dGlsL3dpemFyZC1zdGVwLmludGVyZmFjZSc7XG5pbXBvcnQge01vdmluZ0RpcmVjdGlvbn0gZnJvbSAnLi4vdXRpbC9tb3ZpbmctZGlyZWN0aW9uLmVudW0nO1xuaW1wb3J0IHtDb25maWd1cmFibGVOYXZpZ2F0aW9uTW9kZX0gZnJvbSAnLi4vbmF2aWdhdGlvbi9jb25maWd1cmFibGUtbmF2aWdhdGlvbi1tb2RlJztcblxuLyoqXG4gKiBUaGUgYGF3LXdpemFyZGAgY29tcG9uZW50IGRlZmluZXMgdGhlIHJvb3QgY29tcG9uZW50IG9mIGEgd2l6YXJkLlxuICogVGhyb3VnaCB0aGUgc2V0dGluZyBvZiBpbnB1dCBwYXJhbWV0ZXJzIGZvciB0aGUgYGF3LXdpemFyZGAgY29tcG9uZW50IGl0J3MgcG9zc2libGUgdG8gY2hhbmdlIHRoZSBsb2NhdGlvbiBhbmQgc2l6ZVxuICogb2YgaXRzIG5hdmlnYXRpb24gYmFyLlxuICpcbiAqICMjIyBTeW50YXhcbiAqIGBgYGh0bWxcbiAqIDxhdy13aXphcmQgW25hdkJhckxvY2F0aW9uXT1cImxvY2F0aW9uIG9mIG5hdmlnYXRpb24gYmFyXCIgW25hdkJhckxheW91dF09XCJsYXlvdXQgb2YgbmF2aWdhdGlvbiBiYXJcIj5cbiAqICAgICAuLi5cbiAqIDwvYXctd2l6YXJkPlxuICogYGBgXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBXaXRob3V0IGNvbXBsZXRpb24gc3RlcDpcbiAqXG4gKiBgYGBodG1sXG4gKiA8YXctd2l6YXJkIG5hdkJhckxvY2F0aW9uPVwidG9wXCIgbmF2QmFyTGF5b3V0PVwic21hbGxcIj5cbiAqICAgICA8YXctd2l6YXJkLXN0ZXA+Li4uPC9hdy13aXphcmQtc3RlcD5cbiAqICAgICA8YXctd2l6YXJkLXN0ZXA+Li4uPC9hdy13aXphcmQtc3RlcD5cbiAqIDwvYXctd2l6YXJkPlxuICogYGBgXG4gKlxuICogV2l0aCBjb21wbGV0aW9uIHN0ZXA6XG4gKlxuICogYGBgaHRtbFxuICogPGF3LXdpemFyZCBuYXZCYXJMb2NhdGlvbj1cInRvcFwiIG5hdkJhckxheW91dD1cInNtYWxsXCI+XG4gKiAgICAgPGF3LXdpemFyZC1zdGVwPi4uLjwvYXctd2l6YXJkLXN0ZXA+XG4gKiAgICAgPGF3LXdpemFyZC1zdGVwPi4uLjwvYXctd2l6YXJkLXN0ZXA+XG4gKiAgICAgPGF3LXdpemFyZC1jb21wbGV0aW9uLXN0ZXA+Li4uPC9hdy13aXphcmQtY29tcGxldGlvbi1zdGVwPlxuICogPC9hdy13aXphcmQ+XG4gKiBgYGBcbiAqXG4gKiBAYXV0aG9yIE1hcmMgQXJuZHRcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYXctd2l6YXJkJyxcbiAgdGVtcGxhdGVVcmw6ICd3aXphcmQuY29tcG9uZW50Lmh0bWwnLFxufSlcbmV4cG9ydCBjbGFzcyBXaXphcmRDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgLyoqXG4gICAqIEEgUXVlcnlMaXN0IGNvbnRhaW5pbmcgYWxsIFtbV2l6YXJkU3RlcF1dcyBpbnNpZGUgdGhpcyB3aXphcmRcbiAgICovXG4gIEBDb250ZW50Q2hpbGRyZW4oV2l6YXJkU3RlcCwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KVxuICBwdWJsaWMgd2l6YXJkU3RlcHNRdWVyeUxpc3Q6IFF1ZXJ5TGlzdDxXaXphcmRTdGVwPjtcblxuICAvKipcbiAgICogVGhlIGxvY2F0aW9uIG9mIHRoZSBuYXZpZ2F0aW9uIGJhciBpbnNpZGUgdGhlIHdpemFyZC5cbiAgICogVGhpcyBsb2NhdGlvbiBjYW4gYmUgZWl0aGVyIHRvcCwgYm90dG9tLCBsZWZ0IG9yIHJpZ2h0XG4gICAqL1xuICBASW5wdXQoKVxuICBwdWJsaWMgbmF2QmFyTG9jYXRpb24gPSAndG9wJztcblxuICAvKipcbiAgICogVGhlIGxheW91dCBvZiB0aGUgbmF2aWdhdGlvbiBiYXIgaW5zaWRlIHRoZSB3aXphcmQuXG4gICAqIFRoZSBsYXlvdXQgY2FuIGJlIGVpdGhlciBzbWFsbCwgbGFyZ2UtZmlsbGVkLCBsYXJnZS1lbXB0eSBvciBsYXJnZS1zeW1ib2xzXG4gICAqL1xuICBASW5wdXQoKVxuICBwdWJsaWMgbmF2QmFyTGF5b3V0ID0gJ3NtYWxsJztcblxuICAvKipcbiAgICogVGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGUgc3RlcHMgaW5zaWRlIHRoZSBuYXZpZ2F0aW9uIGJhciBzaG91bGQgYmUgc2hvd24uXG4gICAqIFRoZSBkaXJlY3Rpb24gY2FuIGJlIGVpdGhlciBgbGVmdC10by1yaWdodGAgb3IgYHJpZ2h0LXRvLWxlZnRgXG4gICAqL1xuICBASW5wdXQoKVxuICBwdWJsaWMgbmF2QmFyRGlyZWN0aW9uID0gJ2xlZnQtdG8tcmlnaHQnO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5pdGlhbGx5IHNlbGVjdGVkIHN0ZXAsIHJlcHJlc2VudGVkIGJ5IGl0cyBpbmRleFxuICAgKiBCZXdhcmU6IFRoaXMgaW5pdGlhbCBkZWZhdWx0IGlzIG9ubHkgdXNlZCBpZiBubyB3aXphcmQgc3RlcCBoYXMgYmVlbiBlbmhhbmNlZCB3aXRoIHRoZSBgc2VsZWN0ZWRgIGRpcmVjdGl2ZVxuICAgKi9cbiAgQElucHV0KClcbiAgcHVibGljIGdldCBkZWZhdWx0U3RlcEluZGV4KCk6IG51bWJlciB7XG4gICAgLy8gVGhpcyB2YWx1ZSBjYW4gYmUgZWl0aGVyOlxuICAgIC8vIC0gdGhlIGluZGV4IG9mIGEgd2l6YXJkIHN0ZXAgd2l0aCBhIGBzZWxlY3RlZGAgZGlyZWN0aXZlLCBvclxuICAgIC8vIC0gdGhlIGRlZmF1bHQgc3RlcCBpbmRleCwgc2V0IGluIHRoZSBbW1dpemFyZENvbXBvbmVudF1dXG5cbiAgICBjb25zdCBmb3VuZERlZmF1bHRTdGVwID0gdGhpcy53aXphcmRTdGVwcy5maW5kKHN0ZXAgPT4gc3RlcC5kZWZhdWx0U2VsZWN0ZWQpO1xuXG4gICAgaWYgKGZvdW5kRGVmYXVsdFN0ZXApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEluZGV4T2ZTdGVwKGZvdW5kRGVmYXVsdFN0ZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFN0ZXBJbmRleDtcbiAgICB9XG4gIH1cbiAgcHVibGljIHNldCBkZWZhdWx0U3RlcEluZGV4KGRlZmF1bHRTdGVwSW5kZXg6IG51bWJlcikge1xuICAgIHRoaXMuX2RlZmF1bHRTdGVwSW5kZXggPSBkZWZhdWx0U3RlcEluZGV4O1xuICB9XG4gIHByaXZhdGUgX2RlZmF1bHRTdGVwSW5kZXggPSAwO1xuXG4gIC8qKlxuICAgKiBUcnVlLCBpZiB0aGUgbmF2aWdhdGlvbiBiYXIgc2hvdWxkbid0IGJlIHVzZWQgZm9yIG5hdmlnYXRpbmdcbiAgICovXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBkaXNhYmxlTmF2aWdhdGlvbkJhciA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgbmF2aWdhdGlvbiBtb2RlIHVzZWQgdG8gbmF2aWdhdGUgaW5zaWRlIHRoZSB3aXphcmRcbiAgICpcbiAgICogRm9yIG91dHNpZGUgYWNjZXNzLCB1c2UgdGhlIFtbbmF2aWdhdGlvbl1dIGdldHRlci5cbiAgICovXG4gIHByaXZhdGUgX25hdmlnYXRpb246IE5hdmlnYXRpb25Nb2RlID0gbmV3IENvbmZpZ3VyYWJsZU5hdmlnYXRpb25Nb2RlKCk7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIGFsbCB3aXphcmQgc3RlcHMgYmVsb25naW5nIHRvIHRoaXMgbW9kZWxcbiAgICpcbiAgICogRm9yIG91dHNpZGUgYWNjZXNzLCB1c2UgdGhlIFtbd2l6YXJkU3RlcHNdXSBnZXR0ZXIuXG4gICAqL1xuICBwcml2YXRlIF93aXphcmRTdGVwczogV2l6YXJkU3RlcFtdID0gW107XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IHZpc2libGUgYW5kIHNlbGVjdGVkIHN0ZXAgaW5zaWRlIHRoZSB3aXphcmRTdGVwcyBRdWVyeUxpc3QuXG4gICAqIElmIHRoaXMgd2l6YXJkIGNvbnRhaW5zIG5vIHN0ZXBzLCBjdXJyZW50U3RlcEluZGV4IGlzIC0xXG4gICAqXG4gICAqIE5vdGU6IERvIG5vdCBtb2RpZnkgdGhpcyBmaWVsZCBkaXJlY3RseS4gIEluc3RlYWQsIHVzZSBuYXZpZ2F0aW9uIG1ldGhvZHM6XG4gICAqIFtbZ29Ub1N0ZXBdXSwgW1tnb1RvUHJldmlvdXNTdGVwXV0sIFtbZ29Ub05leHRTdGVwXV0uXG4gICAqL1xuICBwdWJsaWMgY3VycmVudFN0ZXBJbmRleCA9IC0xO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgd2l6YXJkIHVzZXMgYSBob3Jpem9udGFsIG9yaWVudGF0aW9uLlxuICAgKiBUaGUgd2l6YXJkIHVzZXMgYSBob3Jpem9udGFsIG9yaWVudGF0aW9uLCBpZmYgdGhlIG5hdmlnYXRpb24gYmFyIGlzIHNob3duIGF0IHRoZSB0b3Agb3IgYm90dG9tIG9mIHRoaXMgd2l6YXJkXG4gICAqXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyB3aXphcmQgdXNlcyBhIGhvcml6b250YWwgb3JpZW50YXRpb25cbiAgICovXG4gIEBIb3N0QmluZGluZygnY2xhc3MuaG9yaXpvbnRhbCcpXG4gIHB1YmxpYyBnZXQgaG9yaXpvbnRhbE9yaWVudGF0aW9uKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm5hdkJhckxvY2F0aW9uID09PSAndG9wJyB8fCB0aGlzLm5hdkJhckxvY2F0aW9uID09PSAnYm90dG9tJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB3aXphcmQgdXNlcyBhIHZlcnRpY2FsIG9yaWVudGF0aW9uLlxuICAgKiBUaGUgd2l6YXJkIHVzZXMgYSB2ZXJ0aWNhbCBvcmllbnRhdGlvbiwgaWZmIHRoZSBuYXZpZ2F0aW9uIGJhciBpcyBzaG93biBhdCB0aGUgbGVmdCBvciByaWdodCBvZiB0aGlzIHdpemFyZFxuICAgKlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoaXMgd2l6YXJkIHVzZXMgYSB2ZXJ0aWNhbCBvcmllbnRhdGlvblxuICAgKi9cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy52ZXJ0aWNhbCcpXG4gIHB1YmxpYyBnZXQgdmVydGljYWxPcmllbnRhdGlvbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5uYXZCYXJMb2NhdGlvbiA9PT0gJ2xlZnQnIHx8IHRoaXMubmF2QmFyTG9jYXRpb24gPT09ICdyaWdodCc7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6YXRpb24gd29ya1xuICAgKi9cbiAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICAvLyBhZGQgYSBzdWJzY3JpYmVyIHRvIHRoZSB3aXphcmQgc3RlcHMgUXVlcnlMaXN0IHRvIGxpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSBET01cbiAgICB0aGlzLndpemFyZFN0ZXBzUXVlcnlMaXN0LmNoYW5nZXMuc3Vic2NyaWJlKGNoYW5nZWRXaXphcmRTdGVwcyA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZVdpemFyZFN0ZXBzKGNoYW5nZWRXaXphcmRTdGVwcy50b0FycmF5KCkpO1xuICAgIH0pO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgbW9kZWxcbiAgICB0aGlzLnVwZGF0ZVdpemFyZFN0ZXBzKHRoaXMud2l6YXJkU3RlcHNRdWVyeUxpc3QudG9BcnJheSgpKTtcblxuICAgIC8vIGZpbmFsbHkgcmVzZXQgdGhlIHdob2xlIHdpemFyZCBjb21wb25lbnRcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVzZXQoKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFdpemFyZFN0ZXAgb2JqZWN0IGJlbG9uZ2luZyB0byB0aGUgY3VycmVudGx5IHZpc2libGUgYW5kIHNlbGVjdGVkIHN0ZXAuXG4gICAqIFRoZSBjdXJyZW50U3RlcCBpcyBhbHdheXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB3aXphcmQgc3RlcC5cbiAgICogVGhlIGN1cnJlbnRTdGVwIGNhbiBiZSBlaXRoZXIgY29tcGxldGVkLCBpZiBpdCB3YXMgdmlzaXRlZCBlYXJsaWVyLFxuICAgKiBvciBub3QgY29tcGxldGVkLCBpZiBpdCBpcyB2aXNpdGVkIGZvciB0aGUgZmlyc3QgdGltZSBvciBpdHMgc3RhdGUgaXMgY3VycmVudGx5IG91dCBvZiBkYXRlLlxuICAgKlxuICAgKiBJZiB0aGlzIHdpemFyZCBjb250YWlucyBubyBzdGVwcywgY3VycmVudFN0ZXAgaXMgbnVsbFxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50U3RlcCgpOiBXaXphcmRTdGVwIHtcbiAgICBpZiAodGhpcy5oYXNTdGVwKHRoaXMuY3VycmVudFN0ZXBJbmRleCkpIHtcbiAgICAgIHJldHVybiB0aGlzLndpemFyZFN0ZXBzW3RoaXMuY3VycmVudFN0ZXBJbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY29tcGxldGVuZXNzIG9mIHRoZSB3aXphcmQuXG4gICAqIElmIHRoZSB3aXphcmQgaGFzIGJlZW4gY29tcGxldGVkLCBpLmUuIGFsbCBzdGVwcyBhcmUgZWl0aGVyIGNvbXBsZXRlZCBvciBvcHRpb25hbCwgdGhpcyB2YWx1ZSBpcyB0cnVlLCBvdGhlcndpc2UgaXQgaXMgZmFsc2VcbiAgICovXG4gIHB1YmxpYyBnZXQgY29tcGxldGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLndpemFyZFN0ZXBzLmV2ZXJ5KHN0ZXAgPT4gc3RlcC5jb21wbGV0ZWQgfHwgc3RlcC5vcHRpb25hbCk7XG4gIH1cblxuICAvKipcbiAgICogQW4gYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgYWxsIHdpemFyZCBzdGVwcyBiZWxvbmdpbmcgdG8gdGhpcyBtb2RlbFxuICAgKi9cbiAgcHVibGljIGdldCB3aXphcmRTdGVwcygpOiBXaXphcmRTdGVwW10ge1xuICAgIHJldHVybiB0aGlzLl93aXphcmRTdGVwcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB3aXphcmQgc3RlcHMgdG8gdGhlIG5ldyBhcnJheVxuICAgKlxuICAgKiBAcGFyYW0gd2l6YXJkU3RlcHMgVGhlIHVwZGF0ZWQgd2l6YXJkIHN0ZXBzXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZVdpemFyZFN0ZXBzKHdpemFyZFN0ZXBzOiBXaXphcmRTdGVwW10pOiB2b2lkIHtcbiAgICAvLyB0aGUgd2l6YXJkIGlzIGN1cnJlbnRseSBub3QgaW4gdGhlIGluaXRpYWxpemF0aW9uIHBoYXNlXG4gICAgaWYgKHRoaXMud2l6YXJkU3RlcHMubGVuZ3RoID4gMCAmJiB0aGlzLmN1cnJlbnRTdGVwSW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5jdXJyZW50U3RlcEluZGV4ID0gd2l6YXJkU3RlcHMuaW5kZXhPZih0aGlzLndpemFyZFN0ZXBzW3RoaXMuY3VycmVudFN0ZXBJbmRleF0pO1xuICAgIH1cblxuICAgIHRoaXMuX3dpemFyZFN0ZXBzID0gd2l6YXJkU3RlcHM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG5hdmlnYXRpb24gbW9kZSB1c2VkIHRvIG5hdmlnYXRlIGluc2lkZSB0aGUgd2l6YXJkXG4gICAqL1xuICBwdWJsaWMgZ2V0IG5hdmlnYXRpb24oKTogTmF2aWdhdGlvbk1vZGUge1xuICAgIHJldHVybiB0aGlzLl9uYXZpZ2F0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIG5hdmlnYXRpb24gbW9kZSBmb3IgdGhpcyB3aXphcmQgY29tcG9uZW50XG4gICAqXG4gICAqIEBwYXJhbSBuYXZpZ2F0aW9uIFRoZSB1cGRhdGVkIG5hdmlnYXRpb24gbW9kZVxuICAgKi9cbiAgcHVibGljIHNldCBuYXZpZ2F0aW9uKG5hdmlnYXRpb246IE5hdmlnYXRpb25Nb2RlKSB7XG4gICAgdGhpcy5fbmF2aWdhdGlvbiA9IG5hdmlnYXRpb247XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gaW5kZXggYHN0ZXBJbmRleGAgaXMgaW5zaWRlIHRoZSByYW5nZSBvZiBwb3NzaWJsZSB3aXphcmQgc3RlcHMgaW5zaWRlIHRoaXMgd2l6YXJkXG4gICAqXG4gICAqIEBwYXJhbSBzdGVwSW5kZXggVGhlIHRvIGJlIGNoZWNrZWQgaW5kZXggb2YgYSBzdGVwIGluc2lkZSB0aGlzIHdpemFyZFxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBnaXZlbiBgc3RlcEluZGV4YCBpcyBjb250YWluZWQgaW5zaWRlIHRoaXMgd2l6YXJkLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHB1YmxpYyBoYXNTdGVwKHN0ZXBJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMud2l6YXJkU3RlcHMubGVuZ3RoID4gMCAmJiAwIDw9IHN0ZXBJbmRleCAmJiBzdGVwSW5kZXggPCB0aGlzLndpemFyZFN0ZXBzLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyB3aXphcmQgaGFzIGEgcHJldmlvdXMgc3RlcCwgY29tcGFyZWQgdG8gdGhlIGN1cnJlbnQgc3RlcFxuICAgKlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoaXMgd2l6YXJkIGhhcyBhIHByZXZpb3VzIHN0ZXAgYmVmb3JlIHRoZSBjdXJyZW50IHN0ZXBcbiAgICovXG4gIHB1YmxpYyBoYXNQcmV2aW91c1N0ZXAoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaGFzU3RlcCh0aGlzLmN1cnJlbnRTdGVwSW5kZXggLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyB3aXphcmQgaGFzIGEgbmV4dCBzdGVwLCBjb21wYXJlZCB0byB0aGUgY3VycmVudCBzdGVwXG4gICAqXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyB3aXphcmQgaGFzIGEgbmV4dCBzdGVwIGFmdGVyIHRoZSBjdXJyZW50IHN0ZXBcbiAgICovXG4gIHB1YmxpYyBoYXNOZXh0U3RlcCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5oYXNTdGVwKHRoaXMuY3VycmVudFN0ZXBJbmRleCArIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIHdpemFyZCBpcyBjdXJyZW50bHkgaW5zaWRlIGl0cyBsYXN0IHN0ZXBcbiAgICpcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgd2l6YXJkIGlzIGN1cnJlbnRseSBpbnNpZGUgaXRzIGxhc3Qgc3RlcFxuICAgKi9cbiAgcHVibGljIGlzTGFzdFN0ZXAoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMud2l6YXJkU3RlcHMubGVuZ3RoID4gMCAmJiB0aGlzLmN1cnJlbnRTdGVwSW5kZXggPT09IHRoaXMud2l6YXJkU3RlcHMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgW1tXaXphcmRTdGVwXV0gYXQgdGhlIGdpdmVuIGluZGV4IGBzdGVwSW5kZXhgLlxuICAgKiBJZiBubyBbW1dpemFyZFN0ZXBdXSBleGlzdHMgYXQgdGhlIGdpdmVuIGluZGV4IGFuIEVycm9yIGlzIHRocm93blxuICAgKlxuICAgKiBAcGFyYW0gc3RlcEluZGV4IFRoZSBnaXZlbiBpbmRleFxuICAgKiBAcmV0dXJucyBUaGUgZm91bmQgW1tXaXphcmRTdGVwXV0gYXQgdGhlIGdpdmVuIGluZGV4IGBzdGVwSW5kZXhgXG4gICAqIEB0aHJvd3MgQW4gYEVycm9yYCBpcyB0aHJvd24sIGlmIHRoZSBnaXZlbiBpbmRleCBgc3RlcEluZGV4YCBkb2Vzbid0IGV4aXN0XG4gICAqL1xuICBwdWJsaWMgZ2V0U3RlcEF0SW5kZXgoc3RlcEluZGV4OiBudW1iZXIpOiBXaXphcmRTdGVwIHtcbiAgICBpZiAoIXRoaXMuaGFzU3RlcChzdGVwSW5kZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEga25vd24gc3RlcCwgYnV0IGdvdCBzdGVwSW5kZXg6ICR7c3RlcEluZGV4fS5gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy53aXphcmRTdGVwc1tzdGVwSW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgc3RlcCB3aXRoIHRoZSBnaXZlbiBgc3RlcElkYC5cbiAgICogSWYgbm8gc3RlcCB3aXRoIHRoZSBnaXZlbiBgc3RlcElkYCBleGlzdHMsIGAtMWAgaXMgcmV0dXJuZWRcbiAgICpcbiAgICogQHBhcmFtIHN0ZXBJZCBUaGUgZ2l2ZW4gc3RlcCBpZFxuICAgKiBAcmV0dXJucyBUaGUgZm91bmQgaW5kZXggb2YgYSBzdGVwIHdpdGggdGhlIGdpdmVuIHN0ZXAgaWQsIG9yIGAtMWAgaWYgbm8gc3RlcCB3aXRoIHRoZSBnaXZlbiBpZCBpcyBpbmNsdWRlZCBpbiB0aGUgd2l6YXJkXG4gICAqL1xuICBwdWJsaWMgZ2V0SW5kZXhPZlN0ZXBXaXRoSWQoc3RlcElkOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLndpemFyZFN0ZXBzLmZpbmRJbmRleChzdGVwID0+IHN0ZXAuc3RlcElkID09PSBzdGVwSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gW1tXaXphcmRTdGVwXV0gYHN0ZXBgLlxuICAgKiBJZiB0aGUgZ2l2ZW4gW1tXaXphcmRTdGVwXV0gaXMgbm90IGNvbnRhaW5lZCBpbnNpZGUgdGhpcyB3aXphcmQsIGAtMWAgaXMgcmV0dXJuZWRcbiAgICpcbiAgICogQHBhcmFtIHN0ZXAgVGhlIGdpdmVuIFtbV2l6YXJkU3RlcF1dXG4gICAqIEByZXR1cm5zIFRoZSBmb3VuZCBpbmRleCBvZiBgc3RlcGAgb3IgYC0xYCBpZiB0aGUgc3RlcCBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIHdpemFyZFxuICAgKi9cbiAgcHVibGljIGdldEluZGV4T2ZTdGVwKHN0ZXA6IFdpemFyZFN0ZXApOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLndpemFyZFN0ZXBzLmluZGV4T2Yoc3RlcCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgY29ycmVjdCBbW01vdmluZ0RpcmVjdGlvbl1dIHZhbHVlIGZvciBhIGdpdmVuIGBkZXN0aW5hdGlvblN0ZXBgIGNvbXBhcmVkIHRvIHRoZSBgY3VycmVudFN0ZXBJbmRleGAuXG4gICAqXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvblN0ZXAgVGhlIGdpdmVuIGRlc3RpbmF0aW9uIHN0ZXBcbiAgICogQHJldHVybnMgVGhlIGNhbGN1bGF0ZWQgW1tNb3ZpbmdEaXJlY3Rpb25dXVxuICAgKi9cbiAgcHVibGljIGdldE1vdmluZ0RpcmVjdGlvbihkZXN0aW5hdGlvblN0ZXA6IG51bWJlcik6IE1vdmluZ0RpcmVjdGlvbiB7XG4gICAgbGV0IG1vdmluZ0RpcmVjdGlvbjogTW92aW5nRGlyZWN0aW9uO1xuXG4gICAgaWYgKGRlc3RpbmF0aW9uU3RlcCA+IHRoaXMuY3VycmVudFN0ZXBJbmRleCkge1xuICAgICAgbW92aW5nRGlyZWN0aW9uID0gTW92aW5nRGlyZWN0aW9uLkZvcndhcmRzO1xuICAgIH0gZWxzZSBpZiAoZGVzdGluYXRpb25TdGVwIDwgdGhpcy5jdXJyZW50U3RlcEluZGV4KSB7XG4gICAgICBtb3ZpbmdEaXJlY3Rpb24gPSBNb3ZpbmdEaXJlY3Rpb24uQmFja3dhcmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb3ZpbmdEaXJlY3Rpb24gPSBNb3ZpbmdEaXJlY3Rpb24uU3RheTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW92aW5nRGlyZWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcywgd2hldGhlciBhIHdpemFyZCBzdGVwLCBhcyBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBkZXN0aW5hdGlvbiBpbmRleCwgY2FuIGJlIHRyYW5zaXRpb25lZCB0by5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgY29udHJvbHMgbmF2aWdhdGlvbiBieSBbW2dvVG9TdGVwXV0sIFtbZ29Ub1ByZXZpb3VzU3RlcF1dLCBhbmQgW1tnb1RvTmV4dFN0ZXBdXSBkaXJlY3RpdmVzLlxuICAgKiBOYXZpZ2F0aW9uIGJ5IG5hdmlnYXRpb24gYmFyIGlzIGdvdmVybmVkIGJ5IFtbaXNOYXZpZ2FibGVdXS5cbiAgICpcbiAgICogQHBhcmFtIGRlc3RpbmF0aW9uSW5kZXggVGhlIGluZGV4IG9mIHRoZSBkZXN0aW5hdGlvbiBzdGVwXG4gICAqIEByZXR1cm5zIEEgW1tQcm9taXNlXV0gY29udGFpbmluZyBgdHJ1ZWAsIGlmIHRoZSBkZXN0aW5hdGlvbiBzdGVwIGNhbiBiZSB0cmFuc2l0aW9uZWQgdG8gYW5kIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgcHVibGljIGNhbkdvVG9TdGVwKGRlc3RpbmF0aW9uSW5kZXg6IG51bWJlcik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb24uY2FuR29Ub1N0ZXAodGhpcywgZGVzdGluYXRpb25JbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZXMgdG8gdHJhbnNpdGlvbiB0byB0aGUgd2l6YXJkIHN0ZXAsIGFzIGRlbm90ZWQgYnkgdGhlIGdpdmVuIGRlc3RpbmF0aW9uIGluZGV4LlxuICAgKlxuICAgKiBOb3RlOiBZb3UgZG8gbm90IGhhdmUgdG8gY2FsbCBbW2NhbkdvVG9TdGVwXV0gYmVmb3JlIGNhbGxpbmcgW1tnb1RvU3RlcF1dLlxuICAgKiBUaGUgW1tjYW5Hb1RvU3RlcF1dIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5LlxuICAgKlxuICAgKiBAcGFyYW0gZGVzdGluYXRpb25JbmRleCBUaGUgaW5kZXggb2YgdGhlIGRlc3RpbmF0aW9uIHdpemFyZCBzdGVwLCB3aGljaCBzaG91bGQgYmUgZW50ZXJlZFxuICAgKiBAcGFyYW0gcHJlRmluYWxpemUgQW4gZXZlbnQgZW1pdHRlciwgdG8gYmUgY2FsbGVkIGJlZm9yZSB0aGUgc3RlcCBoYXMgYmVlbiB0cmFuc2l0aW9uZWRcbiAgICogQHBhcmFtIHBvc3RGaW5hbGl6ZSBBbiBldmVudCBlbWl0dGVyLCB0byBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHN0ZXAgaGFzIGJlZW4gdHJhbnNpdGlvbmVkXG4gICAqL1xuICBwdWJsaWMgZ29Ub1N0ZXAoZGVzdGluYXRpb25JbmRleDogbnVtYmVyLCBwcmVGaW5hbGl6ZT86IEV2ZW50RW1pdHRlcjx2b2lkPiwgcG9zdEZpbmFsaXplPzogRXZlbnRFbWl0dGVyPHZvaWQ+KTogdm9pZCB7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvbi5nb1RvU3RlcCh0aGlzLCBkZXN0aW5hdGlvbkluZGV4LCBwcmVGaW5hbGl6ZSwgcG9zdEZpbmFsaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmllcyB0byB0cmFuc2l0aW9uIHRoZSB3aXphcmQgdG8gdGhlIHByZXZpb3VzIHN0ZXBcbiAgICpcbiAgICogQHBhcmFtIHByZUZpbmFsaXplIEFuIGV2ZW50IGVtaXR0ZXIsIHRvIGJlIGNhbGxlZCBiZWZvcmUgdGhlIHN0ZXAgaGFzIGJlZW4gdHJhbnNpdGlvbmVkXG4gICAqIEBwYXJhbSBwb3N0RmluYWxpemUgQW4gZXZlbnQgZW1pdHRlciwgdG8gYmUgY2FsbGVkIGFmdGVyIHRoZSBzdGVwIGhhcyBiZWVuIHRyYW5zaXRpb25lZFxuICAgKi9cbiAgcHVibGljIGdvVG9QcmV2aW91c1N0ZXAocHJlRmluYWxpemU/OiBFdmVudEVtaXR0ZXI8dm9pZD4sIHBvc3RGaW5hbGl6ZT86IEV2ZW50RW1pdHRlcjx2b2lkPik6IHZvaWQge1xuICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb24uZ29Ub1N0ZXAodGhpcywgdGhpcy5jdXJyZW50U3RlcEluZGV4IC0gMSwgcHJlRmluYWxpemUsIHBvc3RGaW5hbGl6ZSk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZXMgdG8gdHJhbnNpdGlvbiB0aGUgd2l6YXJkIHRvIHRoZSBuZXh0IHN0ZXBcbiAgICpcbiAgICogQHBhcmFtIHByZUZpbmFsaXplIEFuIGV2ZW50IGVtaXR0ZXIsIHRvIGJlIGNhbGxlZCBiZWZvcmUgdGhlIHN0ZXAgaGFzIGJlZW4gdHJhbnNpdGlvbmVkXG4gICAqIEBwYXJhbSBwb3N0RmluYWxpemUgQW4gZXZlbnQgZW1pdHRlciwgdG8gYmUgY2FsbGVkIGFmdGVyIHRoZSBzdGVwIGhhcyBiZWVuIHRyYW5zaXRpb25lZFxuICAgKi9cbiAgcHVibGljIGdvVG9OZXh0U3RlcChwcmVGaW5hbGl6ZT86IEV2ZW50RW1pdHRlcjx2b2lkPiwgcG9zdEZpbmFsaXplPzogRXZlbnRFbWl0dGVyPHZvaWQ+KTogdm9pZCB7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvbi5nb1RvU3RlcCh0aGlzLCB0aGlzLmN1cnJlbnRTdGVwSW5kZXggKyAxLCBwcmVGaW5hbGl6ZSwgcG9zdEZpbmFsaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MsIHdoZXRoZXIgdGhlIHdpemFyZCBzdGVwLCBsb2NhdGVkIGF0IHRoZSBnaXZlbiBpbmRleCwgY2FuIGJlIG5hdmlnYXRlZCB0byB1c2luZyB0aGUgbmF2aWdhdGlvbiBiYXIuXG4gICAqXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvbkluZGV4IFRoZSBpbmRleCBvZiB0aGUgZGVzdGluYXRpb24gc3RlcFxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzdGVwIGNhbiBiZSBuYXZpZ2F0ZWQgdG8sIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgcHVibGljIGlzTmF2aWdhYmxlKGRlc3RpbmF0aW9uSW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb24uaXNOYXZpZ2FibGUodGhpcywgZGVzdGluYXRpb25JbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBzdGF0ZSBvZiB0aGlzIHdpemFyZC5cbiAgICovXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLm5hdmlnYXRpb24ucmVzZXQodGhpcyk7XG4gIH1cbn1cbiJdfQ==