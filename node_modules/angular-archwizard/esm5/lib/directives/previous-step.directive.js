import { __decorate, __metadata } from "tslib";
import { Directive, EventEmitter, HostListener, Output } from '@angular/core';
import { WizardComponent } from '../components/wizard.component';
/**
 * The `awPreviousStep` directive can be used to navigate to the previous step.
 * Compared to the [[NextStepDirective]] it's important to note, that this directive doesn't contain a `finalize` output method.
 *
 * ### Syntax
 *
 * ```html
 * <button awPreviousStep>...</button>
 * ```
 *
 * @author Marc Arndt
 */
import * as ɵngcc0 from '@angular/core';
var PreviousStepDirective = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param wizard The state of the wizard
     */
    function PreviousStepDirective(wizard) {
        this.wizard = wizard;
        /**
         * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.
         */
        this.preFinalize = new EventEmitter();
        /**
         * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.
         */
        this.postFinalize = new EventEmitter();
    }
    Object.defineProperty(PreviousStepDirective.prototype, "finalize", {
        /**
         * A convenience field for `preFinalize`
         */
        get: function () {
            return this.preFinalize;
        },
        /**
         * A convenience field for `preFinalize`
         *
         * @param emitter The [[EventEmitter]] to be set
         */
        set: function (emitter) {
            /* istanbul ignore next */
            this.preFinalize = emitter;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Listener method for `click` events on the component with this directive.
     * After this method is called the wizard will try to transition to the previous step
     */
    PreviousStepDirective.prototype.onClick = function () {
        this.wizard.goToPreviousStep(this.preFinalize, this.postFinalize);
    };
    PreviousStepDirective.ctorParameters = function () { return [
        { type: WizardComponent }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], PreviousStepDirective.prototype, "preFinalize", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], PreviousStepDirective.prototype, "postFinalize", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter),
        __metadata("design:paramtypes", [EventEmitter])
    ], PreviousStepDirective.prototype, "finalize", null);
    __decorate([
        HostListener('click'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], PreviousStepDirective.prototype, "onClick", null);
    PreviousStepDirective = __decorate([ __metadata("design:paramtypes", [WizardComponent])
    ], PreviousStepDirective);
PreviousStepDirective.ɵfac = function PreviousStepDirective_Factory(t) { return new (t || PreviousStepDirective)(ɵngcc0.ɵɵdirectiveInject(WizardComponent)); };
PreviousStepDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PreviousStepDirective, selectors: [["", "awPreviousStep", ""]], hostBindings: function PreviousStepDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function PreviousStepDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } }, outputs: { preFinalize: "preFinalize", postFinalize: "postFinalize", finalize: "finalize" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PreviousStepDirective, [{
        type: Directive,
        args: [{
                selector: '[awPreviousStep]'
            }]
    }], function () { return [{ type: WizardComponent }]; }, { preFinalize: [{
            type: Output
        }], postFinalize: [{
            type: Output
        }], finalize: [{
            type: Output
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }] }); })();
    return PreviousStepDirective;
}());
export { PreviousStepDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJldmlvdXMtc3RlcC5kaXJlY3RpdmUuanMiLCJzb3VyY2VzIjpbIm5nOi9hbmd1bGFyLWFyY2h3aXphcmQvbGliL2RpcmVjdGl2ZXMvcHJldmlvdXMtc3RlcC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDNUUsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLGdDQUFnQyxDQUFDO0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUlIO0FBRWMsSUFXWjtBQUNGO0FBQ0U7QUFDRTtBQUVKLE9BREs7QUFDTCxJQUFFLCtCQUFvQixNQUF1QjtBQUM3QyxRQURzQixXQUFNLEdBQU4sTUFBTSxDQUFpQjtBQUFDLFFBakI1QztBQUNGO0FBRUEsV0FESztBQUNMLFFBQ1MsZ0JBQVcsR0FBdUIsSUFBSSxZQUFZLEVBQUUsQ0FBQztBQUM5RCxRQUNFO0FBQ0Y7QUFFQSxXQURLO0FBQ0wsUUFDUyxpQkFBWSxHQUF1QixJQUFJLFlBQVksRUFBRSxDQUFDO0FBQy9ELElBT0UsQ0FBQztBQUNILElBSUUsc0JBQVcsMkNBQVE7QUFBSSxRQUh2QjtBQUNGO0FBRUEsV0FESztBQUNMLGFBQUU7QUFBYyxZQUNaLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztBQUM1QixRQUFFLENBQUM7QUFFSCxRQUFFO0FBQ0Y7QUFFQztBQUFXO0FBR1osV0FGSztBQUNMLGFBQ0UsVUFBb0IsT0FBMkI7QUFDakQsWUFBSSwwQkFBMEI7QUFDOUIsWUFBSSxJQUFJLENBQUMsV0FBVyxHQUFHLE9BQU8sQ0FBQztBQUMvQixRQUFFLENBQUM7QUFFSDtBQUNvQjtBQUEyQixPQWQ1QztBQUNILElBWUU7QUFDRjtBQUNFO0FBQ0UsT0FBQztBQUNMLElBQ1MsdUNBQU8sR0FBZDtBQUFjLFFBQ1osSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUN0RSxJQUFFLENBQUM7QUFDRjtBQUNnRSxnQkE5Qm5DLGVBQWU7QUFBRztBQUc1QyxJQWhCRjtBQUFhLFFBRFosTUFBTSxFQUFFO0FBQ1Ysa0NBQXFCLFlBQVk7QUFBRSw4REFBMEI7QUFFOUQsSUFJRTtBQUFhLFFBRFosTUFBTSxFQUFFO0FBQ1Ysa0NBQXNCLFlBQVk7QUFBRSwrREFBMEI7QUFFL0QsSUFxQkU7QUFBYSxRQURaLE1BQU0sRUFBRTtBQUNWLGtDQUE4QixZQUFZO0FBQUcseUNBQWYsWUFBWTtBQUFHLHlEQUczQztBQUVILElBS0U7QUFBYSxRQURaLFlBQVksQ0FBQyxPQUFPLENBQUM7QUFDdkI7QUFDa0I7QUFBNkM7QUFHN0Isd0RBRmhDO0FBQ0YsSUEvQ1kscUJBQXFCLHdCQUhqQyxTQUFTLENBQUMsY0FDVCxRQUFRLEVBQUUsM0NBRUosa0NBa0JzQixlQUFlO1NBcEJmLFVBQzdCLENBQUMscEJBbUI4QyxPQWxCbkMscUJBQXFCLENBK0NqQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFDRDtBQUFDLElBREQsNEJBQUM7QUFDQSxDQURBLEFBL0NELElBK0NDO0FBQ0QsU0FoRGEscUJBQXFCO0FBQ2pDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtXaXphcmRDb21wb25lbnR9IGZyb20gJy4uL2NvbXBvbmVudHMvd2l6YXJkLmNvbXBvbmVudCc7XG5cbi8qKlxuICogVGhlIGBhd1ByZXZpb3VzU3RlcGAgZGlyZWN0aXZlIGNhbiBiZSB1c2VkIHRvIG5hdmlnYXRlIHRvIHRoZSBwcmV2aW91cyBzdGVwLlxuICogQ29tcGFyZWQgdG8gdGhlIFtbTmV4dFN0ZXBEaXJlY3RpdmVdXSBpdCdzIGltcG9ydGFudCB0byBub3RlLCB0aGF0IHRoaXMgZGlyZWN0aXZlIGRvZXNuJ3QgY29udGFpbiBhIGBmaW5hbGl6ZWAgb3V0cHV0IG1ldGhvZC5cbiAqXG4gKiAjIyMgU3ludGF4XG4gKlxuICogYGBgaHRtbFxuICogPGJ1dHRvbiBhd1ByZXZpb3VzU3RlcD4uLi48L2J1dHRvbj5cbiAqIGBgYFxuICpcbiAqIEBhdXRob3IgTWFyYyBBcm5kdFxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbYXdQcmV2aW91c1N0ZXBdJ1xufSlcbmV4cG9ydCBjbGFzcyBQcmV2aW91c1N0ZXBEaXJlY3RpdmUge1xuICAvKipcbiAgICogVGhpcyBbW0V2ZW50RW1pdHRlcl1dIGlzIGNhbGxlZCBkaXJlY3RseSBiZWZvcmUgdGhlIGN1cnJlbnQgc3RlcCBpcyBleGl0ZWQgZHVyaW5nIGEgdHJhbnNpdGlvbiB0aHJvdWdoIGEgY29tcG9uZW50IHdpdGggdGhpcyBkaXJlY3RpdmUuXG4gICAqL1xuICBAT3V0cHV0KClcbiAgcHVibGljIHByZUZpbmFsaXplOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIFRoaXMgW1tFdmVudEVtaXR0ZXJdXSBpcyBjYWxsZWQgZGlyZWN0bHkgYWZ0ZXIgdGhlIGN1cnJlbnQgc3RlcCBpcyBleGl0ZWQgZHVyaW5nIGEgdHJhbnNpdGlvbiB0aHJvdWdoIGEgY29tcG9uZW50IHdpdGggdGhpcyBkaXJlY3RpdmUuXG4gICAqL1xuICBAT3V0cHV0KClcbiAgcHVibGljIHBvc3RGaW5hbGl6ZTogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0gd2l6YXJkIFRoZSBzdGF0ZSBvZiB0aGUgd2l6YXJkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHdpemFyZDogV2l6YXJkQ29tcG9uZW50KSB7XG4gIH1cblxuICAvKipcbiAgICogQSBjb252ZW5pZW5jZSBmaWVsZCBmb3IgYHByZUZpbmFsaXplYFxuICAgKi9cbiAgcHVibGljIGdldCBmaW5hbGl6ZSgpOiBFdmVudEVtaXR0ZXI8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnByZUZpbmFsaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgZmllbGQgZm9yIGBwcmVGaW5hbGl6ZWBcbiAgICpcbiAgICogQHBhcmFtIGVtaXR0ZXIgVGhlIFtbRXZlbnRFbWl0dGVyXV0gdG8gYmUgc2V0XG4gICAqL1xuICBAT3V0cHV0KClcbiAgcHVibGljIHNldCBmaW5hbGl6ZShlbWl0dGVyOiBFdmVudEVtaXR0ZXI8dm9pZD4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRoaXMucHJlRmluYWxpemUgPSBlbWl0dGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbmVyIG1ldGhvZCBmb3IgYGNsaWNrYCBldmVudHMgb24gdGhlIGNvbXBvbmVudCB3aXRoIHRoaXMgZGlyZWN0aXZlLlxuICAgKiBBZnRlciB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgdGhlIHdpemFyZCB3aWxsIHRyeSB0byB0cmFuc2l0aW9uIHRvIHRoZSBwcmV2aW91cyBzdGVwXG4gICAqL1xuICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gIHB1YmxpYyBvbkNsaWNrKCk6IHZvaWQge1xuICAgIHRoaXMud2l6YXJkLmdvVG9QcmV2aW91c1N0ZXAodGhpcy5wcmVGaW5hbGl6ZSwgdGhpcy5wb3N0RmluYWxpemUpO1xuICB9XG59XG4iXX0=