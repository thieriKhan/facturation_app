import { __extends } from "tslib";
import { BaseNavigationMode } from './base-navigation-mode.interface';
import { WizardCompletionStep } from '../util/wizard-completion-step.interface';
/**
 * The default navigation mode used by [[WizardComponent]] and [[NavigationModeDirective]].
 *
 * It is parameterized with two navigation policies passed to constructor:
 *
 * - [[navigateBackward]] policy controls whether wizard steps before the current step are navigable:
 *
 *   - `"deny"` -- the steps are not navigable
 *   - `"allow"` -- the steps are navigable
 *   - If the corresponding constructor argument is omitted or is `null` or `undefined`,
 *     then the default value is applied which is `"deny"`
 *
 * - [[navigateForward]] policy controls whether wizard steps after the current step are navigable:
 *
 *   - `"deny"` -- the steps are not navigable
 *   - `"allow"` -- the steps are navigable
 *   - `"visited"` -- a step is navigable iff it was already visited before
 *   - If the corresponding constructor argument is omitted or is `null` or `undefined`,
 *     then the default value is applied which is `"allow"`
 */
var ConfigurableNavigationMode = /** @class */ (function (_super) {
    __extends(ConfigurableNavigationMode, _super);
    /**
     * Constructor
     *
     * @param navigateBackward Controls whether wizard steps before the current step are navigable
     * @param navigateForward Controls whether wizard steps before the current step are navigable
     */
    function ConfigurableNavigationMode(navigateBackward, navigateForward) {
        if (navigateBackward === void 0) { navigateBackward = null; }
        if (navigateForward === void 0) { navigateForward = null; }
        var _this = _super.call(this) || this;
        _this.navigateBackward = navigateBackward;
        _this.navigateForward = navigateForward;
        _this.navigateBackward = _this.navigateBackward || 'allow';
        _this.navigateForward = _this.navigateForward || 'deny';
        return _this;
    }
    /**
     * @inheritDoc
     */
    ConfigurableNavigationMode.prototype.canTransitionToStep = function (wizard, destinationIndex) {
        // if the destination step can be navigated to using the navigation bar,
        // it should be accessible with [goToStep] as well
        if (this.isNavigable(wizard, destinationIndex)) {
            return true;
        }
        // navigation with [goToStep] is permitted if all previous steps
        // to the destination step have been completed or are optional
        return wizard.wizardSteps
            .filter(function (step, index) { return index < destinationIndex && index !== wizard.currentStepIndex; })
            .every(function (step) { return step.completed || step.optional; });
    };
    /**
     * @inheritDoc
     */
    ConfigurableNavigationMode.prototype.transition = function (wizard, destinationIndex) {
        if (this.navigateForward === 'deny') {
            // set all steps after the destination step to incomplete
            wizard.wizardSteps
                .filter(function (step, index) { return wizard.currentStepIndex > destinationIndex && index > destinationIndex; })
                .forEach(function (step) { return step.completed = false; });
        }
        _super.prototype.transition.call(this, wizard, destinationIndex);
    };
    /**
     * @inheritDoc
     */
    ConfigurableNavigationMode.prototype.isNavigable = function (wizard, destinationIndex) {
        // Check if the destination step can be navigated to
        var destinationStep = wizard.getStepAtIndex(destinationIndex);
        if (destinationStep instanceof WizardCompletionStep) {
            // A completion step can only be entered, if all previous steps have been completed, are optional, or selected
            var previousStepsCompleted = wizard.wizardSteps
                .filter(function (step, index) { return index < destinationIndex; })
                .every(function (step) { return step.completed || step.optional || step.selected; });
            if (!previousStepsCompleted) {
                return false;
            }
        }
        // Apply navigation pocicies
        if (destinationIndex < wizard.currentStepIndex) {
            // If the destination step is before current, apply the `navigateBackward` policy
            switch (this.navigateBackward) {
                case 'allow': return true;
                case 'deny': return false;
                default:
                    throw new Error("Invalid value for navigateBackward: " + this.navigateBackward);
            }
        }
        else if (destinationIndex > wizard.currentStepIndex) {
            // If the destination step is after current, apply the `navigateForward` policy
            switch (this.navigateForward) {
                case 'allow': return true;
                case 'deny': return false;
                case 'visited': return destinationStep.completed;
                default:
                    throw new Error("Invalid value for navigateForward: " + this.navigateForward);
            }
        }
        else {
            // Re-entering the current step is not allowed
            return false;
        }
    };
    /**
     * @inheritDoc
     */
    ConfigurableNavigationMode.prototype.ensureCanReset = function (wizard) {
        _super.prototype.ensureCanReset.call(this, wizard);
        // the default step is a completion step and the wizard contains more than one step
        var defaultWizardStep = wizard.getStepAtIndex(wizard.defaultStepIndex);
        var defaultCompletionStep = defaultWizardStep instanceof WizardCompletionStep;
        if (defaultCompletionStep && wizard.wizardSteps.length !== 1) {
            throw new Error("The default step index " + wizard.defaultStepIndex + " references a completion step");
        }
    };
    return ConfigurableNavigationMode;
}(BaseNavigationMode));
export { ConfigurableNavigationMode };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZmlndXJhYmxlLW5hdmlnYXRpb24tbW9kZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItYXJjaHdpemFyZC8iLCJzb3VyY2VzIjpbImxpYi9uYXZpZ2F0aW9uL2NvbmZpZ3VyYWJsZS1uYXZpZ2F0aW9uLW1vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLGtDQUFrQyxDQUFDO0FBRXBFLE9BQU8sRUFBQyxvQkFBb0IsRUFBQyxNQUFNLDBDQUEwQyxDQUFDO0FBRTlFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUJHO0FBQ0g7SUFBZ0QsOENBQWtCO0lBRWhFOzs7OztPQUtHO0lBQ0gsb0NBQ1UsZ0JBQTRDLEVBQzVDLGVBQXFEO1FBRHJELGlDQUFBLEVBQUEsdUJBQTRDO1FBQzVDLGdDQUFBLEVBQUEsc0JBQXFEO1FBRi9ELFlBSUUsaUJBQU8sU0FHUjtRQU5TLHNCQUFnQixHQUFoQixnQkFBZ0IsQ0FBNEI7UUFDNUMscUJBQWUsR0FBZixlQUFlLENBQXNDO1FBRzdELEtBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFJLENBQUMsZ0JBQWdCLElBQUksT0FBTyxDQUFDO1FBQ3pELEtBQUksQ0FBQyxlQUFlLEdBQUcsS0FBSSxDQUFDLGVBQWUsSUFBSSxNQUFNLENBQUM7O0lBQ3hELENBQUM7SUFFRDs7T0FFRztJQUNPLHdEQUFtQixHQUE3QixVQUE4QixNQUF1QixFQUFFLGdCQUF3QjtRQUM3RSx3RUFBd0U7UUFDeEUsa0RBQWtEO1FBQ2xELElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsRUFBRTtZQUM5QyxPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsZ0VBQWdFO1FBQ2hFLDhEQUE4RDtRQUM5RCxPQUFPLE1BQU0sQ0FBQyxXQUFXO2FBQ3BCLE1BQU0sQ0FBQyxVQUFDLElBQUksRUFBRSxLQUFLLElBQUssT0FBQSxLQUFLLEdBQUcsZ0JBQWdCLElBQUks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RyxpQkFBaUIsWUFBWSxvQkFBb0IsQ0FBQztRQUNoRixJQUFJLHFCQUFxQixJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUM1RCxNQUFNLElBQUksS0FBSyxDQUFDLDRCQUEwQixNQUFNLENBQUMsZ0JBQWdCLGtDQUErQixDQUFDLENBQUM7U0FDbkc7SUFDSCxDQUFDO0lBQ0gsaUNBQUM7QUFBRCxDQUFDLEFBckdELENBQWdELGtCQUFrQixHQXFHakUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0Jhc2VOYXZpZ2F0aW9uTW9kZX0gZnJvbSAnLi9iYXNlLW5hdmlnYXRpb24tbW9kZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHtXaXphcmRDb21wb25lbnR9IGZyb20gJy4uL2NvbXBvbmVudHMvd2l6YXJkLmNvbXBvbmVudCc7XG5pbXBvcnQge1dpemFyZENvbXBsZXRpb25TdGVwfSBmcm9tICcuLi91dGlsL3dpemFyZC1jb21wbGV0aW9uLXN0ZXAuaW50ZXJmYWNlJztcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBuYXZpZ2F0aW9uIG1vZGUgdXNlZCBieSBbW1dpemFyZENvbXBvbmVudF1dIGFuZCBbW05hdmlnYXRpb25Nb2RlRGlyZWN0aXZlXV0uXG4gKlxuICogSXQgaXMgcGFyYW1ldGVyaXplZCB3aXRoIHR3byBuYXZpZ2F0aW9uIHBvbGljaWVzIHBhc3NlZCB0byBjb25zdHJ1Y3RvcjpcbiAqXG4gKiAtIFtbbmF2aWdhdGVCYWNrd2FyZF1dIHBvbGljeSBjb250cm9scyB3aGV0aGVyIHdpemFyZCBzdGVwcyBiZWZvcmUgdGhlIGN1cnJlbnQgc3RlcCBhcmUgbmF2aWdhYmxlOlxuICpcbiAqICAgLSBgXCJkZW55XCJgIC0tIHRoZSBzdGVwcyBhcmUgbm90IG5hdmlnYWJsZVxuICogICAtIGBcImFsbG93XCJgIC0tIHRoZSBzdGVwcyBhcmUgbmF2aWdhYmxlXG4gKiAgIC0gSWYgdGhlIGNvcnJlc3BvbmRpbmcgY29uc3RydWN0b3IgYXJndW1lbnQgaXMgb21pdHRlZCBvciBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsXG4gKiAgICAgdGhlbiB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhcHBsaWVkIHdoaWNoIGlzIGBcImRlbnlcImBcbiAqXG4gKiAtIFtbbmF2aWdhdGVGb3J3YXJkXV0gcG9saWN5IGNvbnRyb2xzIHdoZXRoZXIgd2l6YXJkIHN0ZXBzIGFmdGVyIHRoZSBjdXJyZW50IHN0ZXAgYXJlIG5hdmlnYWJsZTpcbiAqXG4gKiAgIC0gYFwiZGVueVwiYCAtLSB0aGUgc3RlcHMgYXJlIG5vdCBuYXZpZ2FibGVcbiAqICAgLSBgXCJhbGxvd1wiYCAtLSB0aGUgc3RlcHMgYXJlIG5hdmlnYWJsZVxuICogICAtIGBcInZpc2l0ZWRcImAgLS0gYSBzdGVwIGlzIG5hdmlnYWJsZSBpZmYgaXQgd2FzIGFscmVhZHkgdmlzaXRlZCBiZWZvcmVcbiAqICAgLSBJZiB0aGUgY29ycmVzcG9uZGluZyBjb25zdHJ1Y3RvciBhcmd1bWVudCBpcyBvbWl0dGVkIG9yIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCxcbiAqICAgICB0aGVuIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGFwcGxpZWQgd2hpY2ggaXMgYFwiYWxsb3dcImBcbiAqL1xuZXhwb3J0IGNsYXNzIENvbmZpZ3VyYWJsZU5hdmlnYXRpb25Nb2RlIGV4dGVuZHMgQmFzZU5hdmlnYXRpb25Nb2RlIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIG5hdmlnYXRlQmFja3dhcmQgQ29udHJvbHMgd2hldGhlciB3aXphcmQgc3RlcHMgYmVmb3JlIHRoZSBjdXJyZW50IHN0ZXAgYXJlIG5hdmlnYWJsZVxuICAgKiBAcGFyYW0gbmF2aWdhdGVGb3J3YXJkIENvbnRyb2xzIHdoZXRoZXIgd2l6YXJkIHN0ZXBzIGJlZm9yZSB0aGUgY3VycmVudCBzdGVwIGFyZSBuYXZpZ2FibGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgbmF2aWdhdGVCYWNrd2FyZDogJ2FsbG93J3wnZGVueSd8bnVsbCA9IG51bGwsXG4gICAgcHJpdmF0ZSBuYXZpZ2F0ZUZvcndhcmQ6ICdhbGxvdyd8J2RlbnknfCd2aXNpdGVkJ3xudWxsID0gbnVsbCxcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5hdmlnYXRlQmFja3dhcmQgPSB0aGlzLm5hdmlnYXRlQmFja3dhcmQgfHwgJ2FsbG93JztcbiAgICB0aGlzLm5hdmlnYXRlRm9yd2FyZCA9IHRoaXMubmF2aWdhdGVGb3J3YXJkIHx8ICdkZW55JztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgcHJvdGVjdGVkIGNhblRyYW5zaXRpb25Ub1N0ZXAod2l6YXJkOiBXaXphcmRDb21wb25lbnQsIGRlc3RpbmF0aW9uSW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIC8vIGlmIHRoZSBkZXN0aW5hdGlvbiBzdGVwIGNhbiBiZSBuYXZpZ2F0ZWQgdG8gdXNpbmcgdGhlIG5hdmlnYXRpb24gYmFyLFxuICAgIC8vIGl0IHNob3VsZCBiZSBhY2Nlc3NpYmxlIHdpdGggW2dvVG9TdGVwXSBhcyB3ZWxsXG4gICAgaWYgKHRoaXMuaXNOYXZpZ2FibGUod2l6YXJkLCBkZXN0aW5hdGlvbkluZGV4KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gbmF2aWdhdGlvbiB3aXRoIFtnb1RvU3RlcF0gaXMgcGVybWl0dGVkIGlmIGFsbCBwcmV2aW91cyBzdGVwc1xuICAgIC8vIHRvIHRoZSBkZXN0aW5hdGlvbiBzdGVwIGhhdmUgYmVlbiBjb21wbGV0ZWQgb3IgYXJlIG9wdGlvbmFsXG4gICAgcmV0dXJuIHdpemFyZC53aXphcmRTdGVwc1xuICAgICAgICAuZmlsdGVyKChzdGVwLCBpbmRleCkgPT4gaW5kZXggPCBkZXN0aW5hdGlvbkluZGV4ICYmIGluZGV4ICE9PSB3aXphcmQuY3VycmVudFN0ZXBJbmRleClcbiAgICAgICAgLmV2ZXJ5KHN0ZXAgPT4gc3RlcC5jb21wbGV0ZWQgfHwgc3RlcC5vcHRpb25hbCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIHByb3RlY3RlZCB0cmFuc2l0aW9uKHdpemFyZDogV2l6YXJkQ29tcG9uZW50LCBkZXN0aW5hdGlvbkluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uYXZpZ2F0ZUZvcndhcmQgPT09ICdkZW55Jykge1xuICAgICAgLy8gc2V0IGFsbCBzdGVwcyBhZnRlciB0aGUgZGVzdGluYXRpb24gc3RlcCB0byBpbmNvbXBsZXRlXG4gICAgICB3aXphcmQud2l6YXJkU3RlcHNcbiAgICAgICAgLmZpbHRlcigoc3RlcCwgaW5kZXgpID0+IHdpemFyZC5jdXJyZW50U3RlcEluZGV4ID4gZGVzdGluYXRpb25JbmRleCAmJiBpbmRleCA+IGRlc3RpbmF0aW9uSW5kZXgpXG4gICAgICAgIC5mb3JFYWNoKHN0ZXAgPT4gc3RlcC5jb21wbGV0ZWQgPSBmYWxzZSk7XG4gICAgfVxuXG4gICAgc3VwZXIudHJhbnNpdGlvbih3aXphcmQsIGRlc3RpbmF0aW9uSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBwdWJsaWMgaXNOYXZpZ2FibGUod2l6YXJkOiBXaXphcmRDb21wb25lbnQsIGRlc3RpbmF0aW9uSW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIC8vIENoZWNrIGlmIHRoZSBkZXN0aW5hdGlvbiBzdGVwIGNhbiBiZSBuYXZpZ2F0ZWQgdG9cbiAgICBjb25zdCBkZXN0aW5hdGlvblN0ZXAgPSB3aXphcmQuZ2V0U3RlcEF0SW5kZXgoZGVzdGluYXRpb25JbmRleCk7XG4gICAgaWYgKGRlc3RpbmF0aW9uU3RlcCBpbnN0YW5jZW9mIFdpemFyZENvbXBsZXRpb25TdGVwKSB7XG4gICAgICAvLyBBIGNvbXBsZXRpb24gc3RlcCBjYW4gb25seSBiZSBlbnRlcmVkLCBpZiBhbGwgcHJldmlvdXMgc3RlcHMgaGF2ZSBiZWVuIGNvbXBsZXRlZCwgYXJlIG9wdGlvbmFsLCBvciBzZWxlY3RlZFxuICAgICAgY29uc3QgcHJldmlvdXNTdGVwc0NvbXBsZXRlZCA9IHdpemFyZC53aXphcmRTdGVwc1xuICAgICAgICAuZmlsdGVyKChzdGVwLCBpbmRleCkgPT4gaW5kZXggPCBkZXN0aW5hdGlvbkluZGV4KVxuICAgICAgICAuZXZlcnkoc3RlcCA9PiBzdGVwLmNvbXBsZXRlZCB8fCBzdGVwLm9wdGlvbmFsIHx8IHN0ZXAuc2VsZWN0ZWQpO1xuICAgICAgaWYgKCFwcmV2aW91c1N0ZXBzQ29tcGxldGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSBuYXZpZ2F0aW9uIHBvY2ljaWVzXG4gICAgaWYgKGRlc3RpbmF0aW9uSW5kZXggPCB3aXphcmQuY3VycmVudFN0ZXBJbmRleCkge1xuICAgICAgLy8gSWYgdGhlIGRlc3RpbmF0aW9uIHN0ZXAgaXMgYmVmb3JlIGN1cnJlbnQsIGFwcGx5IHRoZSBgbmF2aWdhdGVCYWNrd2FyZGAgcG9saWN5XG4gICAgICBzd2l0Y2ggKHRoaXMubmF2aWdhdGVCYWNrd2FyZCkge1xuICAgICAgICBjYXNlICdhbGxvdyc6IHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdkZW55JzogcmV0dXJuIGZhbHNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3IgbmF2aWdhdGVCYWNrd2FyZDogJHt0aGlzLm5hdmlnYXRlQmFja3dhcmR9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkZXN0aW5hdGlvbkluZGV4ID4gd2l6YXJkLmN1cnJlbnRTdGVwSW5kZXgpIHtcbiAgICAgIC8vIElmIHRoZSBkZXN0aW5hdGlvbiBzdGVwIGlzIGFmdGVyIGN1cnJlbnQsIGFwcGx5IHRoZSBgbmF2aWdhdGVGb3J3YXJkYCBwb2xpY3lcbiAgICAgIHN3aXRjaCAodGhpcy5uYXZpZ2F0ZUZvcndhcmQpIHtcbiAgICAgICAgY2FzZSAnYWxsb3cnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAnZGVueSc6IHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAndmlzaXRlZCc6IHJldHVybiBkZXN0aW5hdGlvblN0ZXAuY29tcGxldGVkO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3IgbmF2aWdhdGVGb3J3YXJkOiAke3RoaXMubmF2aWdhdGVGb3J3YXJkfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS1lbnRlcmluZyB0aGUgY3VycmVudCBzdGVwIGlzIG5vdCBhbGxvd2VkXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBwcm90ZWN0ZWQgZW5zdXJlQ2FuUmVzZXQod2l6YXJkOiBXaXphcmRDb21wb25lbnQpOiB2b2lkIHtcbiAgICBzdXBlci5lbnN1cmVDYW5SZXNldCh3aXphcmQpO1xuXG4gICAgLy8gdGhlIGRlZmF1bHQgc3RlcCBpcyBhIGNvbXBsZXRpb24gc3RlcCBhbmQgdGhlIHdpemFyZCBjb250YWlucyBtb3JlIHRoYW4gb25lIHN0ZXBcbiAgICBjb25zdCBkZWZhdWx0V2l6YXJkU3RlcCA9IHdpemFyZC5nZXRTdGVwQXRJbmRleCh3aXphcmQuZGVmYXVsdFN0ZXBJbmRleCk7XG4gICAgY29uc3QgZGVmYXVsdENvbXBsZXRpb25TdGVwID0gZGVmYXVsdFdpemFyZFN0ZXAgaW5zdGFuY2VvZiBXaXphcmRDb21wbGV0aW9uU3RlcDtcbiAgICBpZiAoZGVmYXVsdENvbXBsZXRpb25TdGVwICYmIHdpemFyZC53aXphcmRTdGVwcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRlZmF1bHQgc3RlcCBpbmRleCAke3dpemFyZC5kZWZhdWx0U3RlcEluZGV4fSByZWZlcmVuY2VzIGEgY29tcGxldGlvbiBzdGVwYCk7XG4gICAgfVxuICB9XG59XG4iXX0=